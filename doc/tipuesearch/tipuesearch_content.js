var tipuesearch = {"pages":[{"title":" Ocotillo ","text":"Ocotillo This is Ocotillo, a code for spectrally resolved, post-processing\nradiative transfer calculations for astrohpysical applications. It uses an implicit method to include scattering in the source function. Developer Info Harrison Cook, Wladimir Lyra","tags":"home","loc":"index.html"},{"title":"file_exists – Ocotillo","text":"public  function file_exists(filename) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical","tags":"","loc":"proc/file_exists.html"},{"title":"itoa – Ocotillo","text":"public  function itoa(n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value character(len=21)","tags":"","loc":"proc/itoa.html"},{"title":"output_ascii – Ocotillo","text":"public  subroutine output_ascii(U, absorp_coeff) Arguments Type Intent Optional Attributes Name real, dimension(mz,nw) :: U real, dimension(nz,nw) :: absorp_coeff","tags":"","loc":"proc/output_ascii.html"},{"title":"output_grid – Ocotillo","text":"public  subroutine output_grid(z, waves) Arguments Type Intent Optional Attributes Name real, dimension(mz) :: z real, dimension(nw) :: waves","tags":"","loc":"proc/output_grid.html"},{"title":"output_binary – Ocotillo","text":"public  subroutine output_binary(U, absorp_coeff, V, iprocx, iprocy, snapshot) Arguments Type Intent Optional Attributes Name real, dimension(mz,nyloc,nxloc,nw) :: U real, dimension(nz,nyloc,nxloc,nw) :: absorp_coeff real, dimension(nz,nyloc,nxloc,nw) :: V integer :: iprocx integer :: iprocy character(len=90) :: snapshot","tags":"","loc":"proc/output_binary.html"},{"title":"read_athena_input – Ocotillo","text":"public  subroutine read_athena_input(inputfile) Arguments Type Intent Optional Attributes Name character(len=90) :: inputfile","tags":"","loc":"proc/read_athena_input.html"},{"title":"read_from_athena – Ocotillo","text":"public  subroutine read_from_athena(z, dz, rho, temp, iprocx, iprocy, snapshot) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(mz) :: z real, intent(out) :: dz real, intent(out), dimension(nz,nyloc,nxloc) :: rho real, intent(out), dimension(nz,nyloc,nxloc) :: temp integer, intent(in) :: iprocx integer, intent(in) :: iprocy character(len=90) :: snapshot","tags":"","loc":"proc/read_from_athena.html"},{"title":"get_electron_thomson_scattering – Ocotillo","text":"public  function get_electron_thomson_scattering(p) result(e_scatter) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p Return Value real, dimension(nz)","tags":"","loc":"proc/get_electron_thomson_scattering.html"},{"title":"get_hydrogen_ion_bound_free – Ocotillo","text":"public  function get_hydrogen_ion_bound_free(p) result(hm_bf_factor) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p Return Value real, dimension(nz)","tags":"","loc":"proc/get_hydrogen_ion_bound_free.html"},{"title":"get_hydrogen_stimulated_emission – Ocotillo","text":"public  function get_hydrogen_stimulated_emission(theta, iw) result(stim_factor) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nz) :: theta integer :: iw Return Value real, dimension(nz)","tags":"","loc":"proc/get_hydrogen_stimulated_emission.html"},{"title":"get_source_function – Ocotillo","text":"public  function get_source_function(T1, iw) result(source_function) Arguments Type Intent Optional Attributes Name real, dimension(nz) :: T1 integer :: iw Return Value real, dimension(nz)","tags":"","loc":"proc/get_source_function.html"},{"title":"calc_wavelength – Ocotillo","text":"public  subroutine calc_wavelength(w1, w0, wa) Arguments Type Intent Optional Attributes Name real, intent(in) :: w1 real, intent(in) :: w0 real, intent(out), dimension(nw) :: wa","tags":"","loc":"proc/calc_wavelength.html"},{"title":"pre_calc_opacity_quantities – Ocotillo","text":"public  subroutine pre_calc_opacity_quantities(waves_angstrom) Arguments Type Intent Optional Attributes Name real, dimension(nw) :: waves_angstrom","tags":"","loc":"proc/pre_calc_opacity_quantities.html"},{"title":"calc_opacity_and_albedo – Ocotillo","text":"public  subroutine calc_opacity_and_albedo(p, iw) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p integer :: iw","tags":"","loc":"proc/calc_opacity_and_albedo.html"},{"title":"grey_parameters – Ocotillo","text":"public  subroutine grey_parameters(p, sigma_grey) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p real, intent(in) :: sigma_grey","tags":"","loc":"proc/grey_parameters.html"},{"title":"read_temperature_input – Ocotillo","text":"public  subroutine read_temperature_input(inputfile) Arguments Type Intent Optional Attributes Name character(len=90) :: inputfile","tags":"","loc":"proc/read_temperature_input.html"},{"title":"read_density_input – Ocotillo","text":"public  subroutine read_density_input(inputfile) Arguments Type Intent Optional Attributes Name character(len=90) :: inputfile","tags":"","loc":"proc/read_density_input.html"},{"title":"calc_grid – Ocotillo","text":"public  subroutine calc_grid(z1, z0, z, dz) Arguments Type Intent Optional Attributes Name real :: z1 real :: z0 real, dimension(mz) :: z real :: dz","tags":"","loc":"proc/calc_grid.html"},{"title":"calc_temperature – Ocotillo","text":"public  subroutine calc_temperature(T, z, lfrom_read_athena) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nz) :: T real, intent(in), dimension(mz) :: z logical, optional :: lfrom_read_athena","tags":"","loc":"proc/calc_temperature.html"},{"title":"calc_density – Ocotillo","text":"public  subroutine calc_density(rho, z) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nz) :: rho real, intent(in), dimension(mz) :: z","tags":"","loc":"proc/calc_density.html"},{"title":"tridag – Ocotillo","text":"public  subroutine tridag(a, b, c, r, u) Solves a tridiagonal system of equations.\nImported from numerical recipes. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a Coefficients for the left-hand side (a, b, c) \nand value of the right-hand side (r) real, intent(in), dimension(:) :: b Coefficients for the left-hand side (a, b, c) \nand value of the right-hand side (r) real, intent(in), dimension(:) :: c Coefficients for the left-hand side (a, b, c) \nand value of the right-hand side (r) real, intent(in), dimension(:) :: r Coefficients for the left-hand side (a, b, c) \nand value of the right-hand side (r) real, intent(out), dimension(:) :: u Value for which to solve.","tags":"","loc":"proc/tridag.html"},{"title":"update_ghosts – Ocotillo","text":"public  subroutine update_ghosts(f) Update the ghost zones of an array \nusing constant gradient. Used on U. Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: f Array to update.","tags":"","loc":"proc/update_ghosts.html"},{"title":"der – Ocotillo","text":"public  subroutine der(f, df) Calculate the sixth-order first derivative of an array. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(mz) :: f Array to calculate the derivative including ghost zones. real, intent(out), dimension(nz) :: df Derivative of the array.","tags":"","loc":"proc/der.html"},{"title":"calc_intensity – Ocotillo","text":"public  subroutine calc_intensity(U, V, Ip, Im) Calculate upwards (Ip) and downwards (Im) intensities\n from U and V. Arguments Type Intent Optional Attributes Name real, dimension(mz,nw) :: U Mean intensity array. real, dimension(nz,nw) :: V Flux, upward intensity, and downward intensity. real, dimension(nz,nw) :: Ip Flux, upward intensity, and downward intensity. real, dimension(nz,nw) :: Im Flux, upward intensity, and downward intensity.","tags":"","loc":"proc/calc_intensity.html"},{"title":"calc_flux – Ocotillo","text":"public  subroutine calc_flux(U, p, dz1) Calculate flux (V) from the mean intensity (U) and opacity ( ) Arguments Type Intent Optional Attributes Name real, dimension(mz) :: U Mean intensity array. type(pillar_case) :: p Pillar object containing the radiative transfer quantitites. real :: dz1 Inverse of the grid size along z:","tags":"","loc":"proc/calc_flux.html"},{"title":"get_tridag_coefficients – Ocotillo","text":"public  subroutine get_tridag_coefficients(aa, bb, cc, dd, p, dz, dz2) Fill in the coefficients of the system of equations in U. Note Center and boundary coefficients are calculated differently. Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nz) :: aa Tridiag system coefficients real, intent(inout), dimension(nz) :: bb Tridiag system coefficients real, intent(inout), dimension(nz) :: cc Tridiag system coefficients real, intent(inout), dimension(nz) :: dd Tridiag system coefficients type(pillar_case) :: p Pillar object to update. real, intent(in) :: dz Grid size (dz) and its square (dz2) along z. real, intent(in) :: dz2 Grid size (dz) and its square (dz2) along z.","tags":"","loc":"proc/get_tridag_coefficients.html"},{"title":"get_electron_pressure – Ocotillo","text":"public  function get_electron_pressure(p) result(electron_pressure) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p Return Value real, dimension(nz)","tags":"","loc":"proc/get_electron_pressure.html"},{"title":"read_gas_state_input – Ocotillo","text":"public  subroutine read_gas_state_input(inputfile) Arguments Type Intent Optional Attributes Name character(len=90) :: inputfile","tags":"","loc":"proc/read_gas_state_input.html"},{"title":"wavelength_independent_pillars – Ocotillo","text":"public  subroutine wavelength_independent_pillars(p) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p","tags":"","loc":"proc/wavelength_independent_pillars.html"},{"title":"calc_hydrogen_ion_frac – Ocotillo","text":"public  subroutine calc_hydrogen_ion_frac(p) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p","tags":"","loc":"proc/calc_hydrogen_ion_frac.html"},{"title":"solve_gas_state – Ocotillo","text":"public  subroutine solve_gas_state(p) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p","tags":"","loc":"proc/solve_gas_state.html"},{"title":"FileIO – Ocotillo","text":"Uses Common Functions public  function file_exists (filename) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical public  function itoa (n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value character(len=21) Subroutines public  subroutine output_ascii (U, absorp_coeff) Arguments Type Intent Optional Attributes Name real, dimension(mz,nw) :: U real, dimension(nz,nw) :: absorp_coeff public  subroutine output_grid (z, waves) Arguments Type Intent Optional Attributes Name real, dimension(mz) :: z real, dimension(nw) :: waves public  subroutine output_binary (U, absorp_coeff, V, iprocx, iprocy, snapshot) Arguments Type Intent Optional Attributes Name real, dimension(mz,nyloc,nxloc,nw) :: U real, dimension(nz,nyloc,nxloc,nw) :: absorp_coeff real, dimension(nz,nyloc,nxloc,nw) :: V integer :: iprocx integer :: iprocy character(len=90) :: snapshot","tags":"","loc":"module/fileio.html"},{"title":"ReadAthena – Ocotillo","text":"Uses Common FileIO iso_c_binding Disk Subroutines public  subroutine read_athena_input (inputfile) Arguments Type Intent Optional Attributes Name character(len=90) :: inputfile public  subroutine read_from_athena (z, dz, rho, temp, iprocx, iprocy, snapshot) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(mz) :: z real, intent(out) :: dz real, intent(out), dimension(nz,nyloc,nxloc) :: rho real, intent(out), dimension(nz,nyloc,nxloc) :: temp integer, intent(in) :: iprocx integer, intent(in) :: iprocy character(len=90) :: snapshot","tags":"","loc":"module/readathena.html"},{"title":"ContinuousOpacity – Ocotillo","text":"Uses Common Functions public  function get_electron_thomson_scattering (p) result(e_scatter) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p Return Value real, dimension(nz) public  function get_hydrogen_ion_bound_free (p) result(hm_bf_factor) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p Return Value real, dimension(nz) public  function get_hydrogen_stimulated_emission (theta, iw) result(stim_factor) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(nz) :: theta integer :: iw Return Value real, dimension(nz) public  function get_source_function (T1, iw) result(source_function) Arguments Type Intent Optional Attributes Name real, dimension(nz) :: T1 integer :: iw Return Value real, dimension(nz) Subroutines public  subroutine calc_wavelength (w1, w0, wa) Arguments Type Intent Optional Attributes Name real, intent(in) :: w1 real, intent(in) :: w0 real, intent(out), dimension(nw) :: wa public  subroutine pre_calc_opacity_quantities (waves_angstrom) Arguments Type Intent Optional Attributes Name real, dimension(nw) :: waves_angstrom public  subroutine calc_opacity_and_albedo (p, iw) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p integer :: iw public  subroutine grey_parameters (p, sigma_grey) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p real, intent(in) :: sigma_grey","tags":"","loc":"module/continuousopacity.html"},{"title":"Disk – Ocotillo","text":"Uses Common Subroutines public  subroutine read_temperature_input (inputfile) Arguments Type Intent Optional Attributes Name character(len=90) :: inputfile public  subroutine read_density_input (inputfile) Arguments Type Intent Optional Attributes Name character(len=90) :: inputfile public  subroutine calc_grid (z1, z0, z, dz) Arguments Type Intent Optional Attributes Name real :: z1 real :: z0 real, dimension(mz) :: z real :: dz public  subroutine calc_temperature (T, z, lfrom_read_athena) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nz) :: T real, intent(in), dimension(mz) :: z logical, optional :: lfrom_read_athena public  subroutine calc_density (rho, z) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nz) :: rho real, intent(in), dimension(mz) :: z","tags":"","loc":"module/disk.html"},{"title":"Auxiliary – Ocotillo","text":"Auxiliary subroutines used throughout the code. Uses Common Subroutines public  subroutine tridag (a, b, c, r, u) Solves a tridiagonal system of equations.\nImported from numerical recipes. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: a Coefficients for the left-hand side (a, b, c) \nand value of the right-hand side (r) real, intent(in), dimension(:) :: b Coefficients for the left-hand side (a, b, c) \nand value of the right-hand side (r) real, intent(in), dimension(:) :: c Coefficients for the left-hand side (a, b, c) \nand value of the right-hand side (r) real, intent(in), dimension(:) :: r Coefficients for the left-hand side (a, b, c) \nand value of the right-hand side (r) real, intent(out), dimension(:) :: u Value for which to solve. public  subroutine update_ghosts (f) Update the ghost zones of an array \nusing constant gradient. Used on U. Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:) :: f Array to update. public  subroutine der (f, df) Calculate the sixth-order first derivative of an array. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(mz) :: f Array to calculate the derivative including ghost zones. real, intent(out), dimension(nz) :: df Derivative of the array. public  subroutine calc_intensity (U, V, Ip, Im) Calculate upwards (Ip) and downwards (Im) intensities\n from U and V. Read more… Arguments Type Intent Optional Attributes Name real, dimension(mz,nw) :: U Mean intensity array. real, dimension(nz,nw) :: V Flux, upward intensity, and downward intensity. real, dimension(nz,nw) :: Ip Flux, upward intensity, and downward intensity. real, dimension(nz,nw) :: Im Flux, upward intensity, and downward intensity. public  subroutine calc_flux (U, p, dz1) Calculate flux (V) from the mean intensity (U) and opacity ( ) Arguments Type Intent Optional Attributes Name real, dimension(mz) :: U Mean intensity array. type(pillar_case) :: p Pillar object containing the radiative transfer quantitites. real :: dz1 Inverse of the grid size along z: public  subroutine get_tridag_coefficients (aa, bb, cc, dd, p, dz, dz2) Fill in the coefficients of the system of equations in U. Read more… Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(nz) :: aa Tridiag system coefficients real, intent(inout), dimension(nz) :: bb Tridiag system coefficients real, intent(inout), dimension(nz) :: cc Tridiag system coefficients real, intent(inout), dimension(nz) :: dd Tridiag system coefficients type(pillar_case) :: p Pillar object to update. real, intent(in) :: dz Grid size (dz) and its square (dz2) along z. real, intent(in) :: dz2 Grid size (dz) and its square (dz2) along z.","tags":"","loc":"module/auxiliary.html"},{"title":"GasState – Ocotillo","text":"Uses Common ContinuousOpacity Functions public  function get_electron_pressure (p) result(electron_pressure) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p Return Value real, dimension(nz) Subroutines public  subroutine read_gas_state_input (inputfile) Arguments Type Intent Optional Attributes Name character(len=90) :: inputfile public  subroutine wavelength_independent_pillars (p) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p public  subroutine calc_hydrogen_ion_frac (p) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p public  subroutine solve_gas_state (p) Arguments Type Intent Optional Attributes Name type(pillar_case) :: p","tags":"","loc":"module/gasstate.html"},{"title":"flux_feautrier – Ocotillo","text":"Uses Auxiliary Common GasState ReadAthena FileIO Disk ContinuousOpacity Variables Type Attributes Name Initial type(pillar_case) :: p real, dimension(mz,nyloc,nxloc,nw) :: U real, dimension(:,:,:,:), allocatable :: V real, dimension(:,:,:,:), allocatable :: absorp_coeff real, dimension(nz,nyloc,nxloc) :: rho3d real, dimension(nz,nyloc,nxloc) :: temp3d real, dimension(mz) :: z real, dimension(nz) :: a real, dimension(nz) :: b real, dimension(nz) :: c real, dimension(nz) :: d real, dimension(nw) :: waves_angstrom real :: dz real :: z0 real :: z1 real :: dz1 real :: dz2 real :: start real :: finish real :: start_loop real :: finish_loop real :: w0 = 3000 real :: w1 = 5000 real :: sigma_grey integer :: iw integer :: ix integer :: iy integer :: iprocx integer :: iprocy integer :: err logical :: lgrey = .false. logical :: lread_athena = .true. character(len=90) :: snapshot character(len=90) :: inputfile = './input.in' Namelists Namelist input Variables Name Type Default Description z0 real None z1 real None w0 real 3000 w1 real 5000 sigma_grey real None lgrey logical .false. lread_athena logical .true.","tags":"","loc":"program/flux_feautrier.html"},{"title":"  input – Ocotillo\n","text":"Variables Name Type Default Description z0 real None z1 real None w0 real 3000 w1 real 5000 sigma_grey real None lgrey logical .false. lread_athena logical .true.","tags":"","loc":"namelist/input.html"},{"title":"io.f90 – Ocotillo","text":"Source Code module FileIO use Common implicit none private public :: output_ascii , output_grid , itoa , file_exists , output_binary contains !************************************************************************************ function file_exists ( filename ) result ( res ) implicit none character ( len =* ), intent ( in ) :: filename logical :: res ! Check if the file exists inquire ( file = trim ( filename ), exist = res ) endfunction file_exists !************************************************************************************ character ( len = 21 ) function itoa ( n ) ! plucked from pencil integer , intent ( in ) :: n ! write ( itoa , '(I21)' ) n ! (64 bit integer plus sign) itoa = adjustl ( itoa ) ! endfunction itoa !************************************************************************************ subroutine output_ascii ( U , absorp_coeff ) real , dimension ( mz , nw ) :: U real , dimension ( nz , nw ) :: absorp_coeff integer :: i , iw character ( len = 20 ) :: format_string write ( format_string , '(\"(I6,\",I0,\"(2e15.5))\")' ) nw open ( 10 , file = \"output/diagnostics.txt\" , status = \"replace\" , action = 'write' ) do i = 1 , nz write ( unit = 10 , FMT = format_string ) i , ( U ( n1 + i - 1 , iw ), iw = 1 , nw ), ( absorp_coeff ( i , iw ), iw = 1 , nw ) enddo close ( 10 ) endsubroutine output_ascii !************************************************************************************ subroutine output_grid ( z , waves ) real , dimension ( mz ) :: z real , dimension ( nw ) :: waves integer :: i ! open ( 15 , file = \"output/zgrid.txt\" , status = \"replace\" , action = 'write' ) do i = 1 , nz write ( unit = 15 , FMT =* ) i , z ( n1 + i - 1 ) enddo close ( 15 ) ! open ( 55 , file = \"output/zgrid.bin\" , form = \"unformatted\" , status = \"replace\" , action = \"write\" ) write ( 55 ) z close ( 55 ) open ( 25 , file = \"output/wavegrid.txt\" , status = \"replace\" , action = \"write\" ) do i = 1 , nw write ( unit = 25 , FMT =* ) i , waves ( i ) enddo close ( 25 ) open ( 65 , file = \"output/wavegrid.bin\" , form = \"unformatted\" , status = \"replace\" , action = \"write\" ) write ( 65 ) waves close ( 65 ) ! endsubroutine output_grid !************************************************************************************ subroutine output_binary ( U , absorp_coeff , V , iprocx , iprocy , snapshot ) real , dimension ( mz , nyloc , nxloc , nw ) :: U real , dimension ( nz , nyloc , nxloc , nw ) :: absorp_coeff , V integer :: iprocx , iprocy character ( len = 90 ) :: outputdir , snapshot outputdir = 'output/procx' // trim ( itoa ( iprocx )) // '_procy' // trim ( itoa ( iprocy )) call system ( 'mkdir -p ' // trim ( outputdir )) open ( 35 , file = trim ( outputdir ) // '/mean_intensity_' // trim ( snapshot ) // '.bin' , & form = 'unformatted' , status = 'replace' , action = 'write' ) write ( 35 ) U close ( 35 ) open ( 45 , file = trim ( outputdir ) // '/absorption_coefficients_' // trim ( snapshot ) // '.bin' , & form = 'unformatted' , status = 'replace' , action = 'write' ) write ( 45 ) absorp_coeff close ( 45 ) open ( 75 , file = trim ( outputdir ) // '/flux_' // trim ( snapshot ) // '.bin' , & form = 'unformatted' , status = 'replace' , action = 'write' ) write ( 75 ) V close ( 75 ) endsubroutine output_binary !************************************************************************************ end module FileIO","tags":"","loc":"sourcefile/io.f90.html"},{"title":"read_athena.f90 – Ocotillo","text":"Source Code module ReadAthena use Common use Disk use FileIO use , intrinsic :: iso_c_binding , only : c_float , c_double , c_int implicit none private public :: read_from_athena , read_athena_input character ( len = 90 ) :: RunName character ( len = 90 ) :: datadir = \"./input_athena/distributed\" real :: Mbh_SolarMasses , r0ref_rg real :: aspect_ratio , mean_molecular_weight , rho0 , rho_floor real :: rg , Mbh , rr , g0 , Omega , H real :: unit_time , unit_length , unit_velocity real :: unit_density , unit_temperature integer :: nzloc_aux logical :: lavoid_momentum_underflow = . true . namelist / athena_input / RunName , Mbh_SolarMasses , r0ref_rg ,& aspect_ratio , mean_molecular_weight , rho0 , datadir , rho_floor ,& lavoid_momentum_underflow contains !************************************************************************************ subroutine read_athena_input ( inputfile ) ! character ( len = 90 ) :: inputfile ! open ( 40 , file = trim ( inputfile )) read ( 40 , nml = athena_input ) close ( 40 ) ! Mbh = Mbh_SolarMasses * SolarMass rg = 2 * ( G_Newton_cgs / c_light_cgs ** 2 ) * Mbh rr = r0ref_rg * rg g0 = G_Newton_cgs * Mbh Omega = sqrt ( g0 ) * rr ** ( - 1.5 ) H = aspect_ratio * rr ! ! code units for conversion ! unit_density = rho0 unit_time = 1. / Omega unit_length = H unit_velocity = unit_length / unit_time unit_temperature = mean_molecular_weight * amu * k1_cgs * unit_velocity ** 2 ! print * , 'unit_time        = ' , unit_time , ' s' print * , 'unit_length      = ' , unit_length , ' cm' print * , 'unit_velocity    = ' , unit_velocity , ' cm/s' print * , 'unit_density     = ' , unit_density , ' g/cm3' print * , 'unit_temperature = ' , unit_temperature , ' K' ! endsubroutine read_athena_input !************************************************************************************ subroutine read_from_athena ( z , dz , rho , temp , iprocx , iprocy , snapshot ) ! integer ( c_int ) :: nxloc_ , nyloc_ , nzloc real ( c_double ) :: gamma1 integer ( c_int ) :: dummy1_int ! coordsys integer ( c_int ) :: dummy2_int , dummy3_int !nvar,nscalars integer ( c_int ) :: dummy4_int , dummy5_int !selfgrav_boolean, particles_boolean real ( c_double ) :: dummy1_real , dummy2_real , dummy3_real !cs,t,dt ! real ( c_double ), dimension ( nxloc ) :: xloc real ( c_double ), dimension ( nyloc ) :: yloc real ( c_double ), allocatable :: zloc (:) !real(c_double), dimension(nzloc,nyloc,nxloc) :: tmp_loc !      real(c_double), allocatable :: xloc(:),yloc(:),zloc(:) real ( c_double ), allocatable :: tmp_loc (:,:,:), tmp_loc_transpose (:,:,:) ! real , dimension ( nz , nyloc , nxloc ), intent ( out ) :: rho , temp ! real , dimension ( mz ), intent ( out ) :: z real , dimension ( nz ) :: zn real , intent ( out ) :: dz integer :: iproc , iprocz integer , intent ( in ) :: iprocx , iprocy character ( len = 90 ) :: head , tail , filename , sproc , base , snapshot ! real :: z0 integer :: iz0 integer :: iz1 !order: !coordsys,nx,ny,nz,nvar,nscalars,selfgrav_boolean, particles_boolean,gamma1,cs,t,dt,x,y,z,rho,rux,ruy,ruz,eng ! base = trim ( datadir ) // \"/id\" tail = \".\" // trim ( snapshot ) // \".bin\" do iprocz = 0 , nprocz - 1 iproc = modulo ( iprocz , nprocz ) * nprocx * nprocy + modulo ( iprocy , nprocy ) * nprocx + modulo ( iprocx , nprocx ) sproc = itoa ( iproc ) head = trim ( base ) // trim ( sproc ) // \"/\" // trim ( RunName ) if ( iproc == 0 ) then filename = trim ( head ) // trim ( tail ) else filename = trim ( head ) // \"-id\" // trim ( sproc ) // trim ( tail ) endif if ( file_exists ( trim ( filename )) . eqv . . false .) then print * , \"iproc=\" , iproc print * , \"File \" , trim ( filename ), \" does not exist\" stop endif open ( 99 , file = trim ( filename ), form = 'unformatted' , ACCESS = 'stream' ) read ( 99 ) dummy1_int !coordsys ! ! Sanity check ! read ( 99 ) nxloc_ if ( nxloc_ /= nxloc ) then print * , \"Resolution in x from Athena = \" , nxloc_ print * , \"RT x-dimensionality from resolution.in = \" , nxloc print * , \"The Athena x dimensionality does not match the chosen for the RT post-processing. Fix.\" stop endif read ( 99 ) nyloc_ if ( nyloc_ /= nyloc ) then print * , \"Resolution in y from Athena = \" , nyloc_ print * , \"RT y-dimensionality from resolution.in = \" , nyloc print * , \"The Athena y dimensionality does not match the chosen for the RT post-processing. Fix.\" stop endif read ( 99 ) nzloc nzloc_aux = nzloc ! read ( 99 ) dummy2_int , dummy3_int , dummy4_int , dummy5_int !nvar,nscalars,selfgrav_boolean, particles_boolean read ( 99 ) gamma1 read ( 99 ) dummy1_real , dummy2_real , dummy3_real !cs,t,dt ! read ( 99 ) xloc read ( 99 ) yloc allocate ( zloc ( nzloc )) read ( 99 ) zloc ! if ( iprocz == 0 ) then z0 = zloc ( 1 ) dz = zloc ( 2 ) - zloc ( 1 ) endif iz0 = nint (( zloc ( 1 ) - z0 ) / dz ) + 1 iz1 = iz0 + nzloc - 1 ! zn ( iz0 : iz1 ) = zloc ! allocate ( tmp_loc ( nxloc , nyloc , nzloc )) allocate ( tmp_loc_transpose ( nzloc , nyloc , nxloc )) ! !rho1=1./rho(:,iy,ix) !ekin = 0.5*rho1*ru2(:,iy,ix) !eint = eng(:,iy,ix) - ekin !cs2 = gamma*gamma1 * eint * rho1 !temp(:,iy,ix) = mean_molecular_weight * amu * cs2 * gamma_inv * k1_cgs read ( 99 ) tmp_loc ; call transpose_loc ( tmp_loc , tmp_loc_transpose ) rho ( iz0 : iz1 ,:,:) = tmp_loc_transpose ! ! Build kinetic energy; ekin = (rux**2+ruy**2+ruz**2)/(2*rho) ! temp ( iz0 : iz1 ,:,:) = 0.0 read ( 99 ) tmp_loc ; call transpose_loc ( tmp_loc , tmp_loc_transpose ) !rux if (. not . lavoid_momentum_underflow ) then temp ( iz0 : iz1 ,:,:) = temp ( iz0 : iz1 ,:,:) + . 5 * tmp_loc_transpose ** 2 / rho ( iz0 : iz1 ,:,:) else call fix_momentum_underflow ( tmp_loc_transpose , temp , rho , iz0 , iz1 ) endif read ( 99 ) tmp_loc ; call transpose_loc ( tmp_loc , tmp_loc_transpose ) !ruy if (. not . lavoid_momentum_underflow ) then temp ( iz0 : iz1 ,:,:) = temp ( iz0 : iz1 ,:,:) + . 5 * tmp_loc_transpose ** 2 / rho ( iz0 : iz1 ,:,:) else call fix_momentum_underflow ( tmp_loc_transpose , temp , rho , iz0 , iz1 ) endif read ( 99 ) tmp_loc ; call transpose_loc ( tmp_loc , tmp_loc_transpose ) !ruz if (. not . lavoid_momentum_underflow ) then temp ( iz0 : iz1 ,:,:) = temp ( iz0 : iz1 ,:,:) + . 5 * tmp_loc_transpose ** 2 / rho ( iz0 : iz1 ,:,:) else call fix_momentum_underflow ( tmp_loc_transpose , temp , rho , iz0 , iz1 ) endif ! ! Define internal energy; eint = eng - ekin. ! Then the sound speed; cs2 = gamma*gamma1 * eint * rho1 ! The gammas and the constants will be added in the next subroutine ! read ( 99 ) tmp_loc ; call transpose_loc ( tmp_loc , tmp_loc_transpose ) !eng temp ( iz0 : iz1 ,:,:) = ( tmp_loc_transpose - temp ( iz0 : iz1 ,:,:)) / rho ( iz0 : iz1 ,:,:) deallocate ( tmp_loc , zloc , tmp_loc_transpose ) close ( 99 ) enddo ! call postprocess_athena_values ( rho , temp , zn , z , dz , gamma1 ) ! endsubroutine read_from_athena !************************************************************************************ subroutine fix_momentum_underflow ( pp , temp , rho , iz0 , iz1 ) ! real ( c_double ), dimension ( nzloc_aux , nyloc , nxloc ), intent ( in ) :: pp real , dimension ( nz , nyloc , nxloc ), intent ( inout ) :: temp , rho integer , intent ( in ) :: iz0 , iz1 integer :: ix , iy , iz , jz ! do jz = iz0 , iz1 iz = jz - iz0 + 1 do iy = 1 , nyloc ; do ix = 1 , nxloc if ( abs ( pp ( iz , iy , ix )) . ge . epsilon ( 0.0 )) & temp ( jz , iy , ix ) = temp ( jz , iy , ix ) + . 5 * pp ( iz , iy , ix ) ** 2 / rho ( jz , iy , ix ) enddo ; enddo enddo ! endsubroutine fix_momentum_underflow !************************************************************************************ subroutine postprocess_athena_values ( rho , temp , zn , z , dz , gamma1 ) ! real , dimension ( nz , nyloc , nxloc ), intent ( inout ) :: rho , temp real , dimension ( mz ), intent ( out ) :: z real , dimension ( nz ) :: zn real , intent ( in ) :: gamma1 real , intent ( out ) :: dz ! integer :: i , ix , iy ! ! Apply density floor after converting to physical units ! rho = rho * unit_density if ( ISNAN ( rho_floor )) then print * , \"\" print * , \"Must set `rho_floor` (cgs) value in namelist: `input.in/athena_input`.\" print * , \"\" stop ! quit program else ! Apply density floor where ( rho < rho_floor ) rho = rho_floor endif ! ! convert temperature to physical units ! temp = temp * gamma1 * unit_temperature ! zn = zn * unit_length dz = ( zn ( nz ) - zn ( 1 )) / ( nz - 1 ) z ( n1 : n2 ) = zn ! Fill in ghost zones do i = 1 , ng z ( n1 - i ) = z ( n1 ) - i * dz z ( n2 + i ) = z ( n2 ) + i * dz enddo ! do ix = 1 , nxloc ; do iy = 1 , nyloc call calc_temperature ( temp (:, iy , ix ), z , lfrom_read_athena = . true .) enddo ; enddo ! if ( lroot ) then print * , 'minval(rho),maxval(rho),mean(rho)' ,& minval ( rho ), maxval ( rho ), sum ( rho ) / ( nxloc * nyloc * nz ) print * , 'minval(T),maxval(T),mean(T)' ,& minval ( temp ), maxval ( temp ), sum ( temp ) / ( nxloc * nyloc * nz ) endif ! endsubroutine postprocess_athena_values !************************************************************************************ subroutine transpose_loc ( a , b ) ! real , dimension (:,:,:), intent ( in ) :: a real , dimension (:,:,:), intent ( out ) :: b real , dimension ( size ( a , 1 ), size ( a , 2 )) :: buffer integer :: i ! do i = 1 , size ( a , 3 ) buffer = a (:,:, i ) b ( i ,:,:) = transpose ( buffer ) enddo ! endsubroutine transpose_loc !************************************************************************************ endmodule ReadAthena","tags":"","loc":"sourcefile/read_athena.f90.html"},{"title":"continuous_opacity.f90 – Ocotillo","text":"Source Code ! Module to calculate hydrogen cross sections as described !   in Gray's (2022) description of continuous opacity in !   stellar atmospheres. module ContinuousOpacity use Common implicit none private public :: get_hydrogen_stimulated_emission public :: get_electron_thomson_scattering public :: get_hydrogen_ion_bound_free public :: calc_opacity_and_albedo public :: grey_parameters public :: pre_calc_opacity_quantities public :: get_source_function public :: calc_wavelength real :: switch_ionfraction = 1e-2 real , dimension ( 7 ) :: a_coeff real , dimension ( 3 , 5 ) :: b_coeff real :: AHbf = 1.0449e-26 real :: Rangstrom = 1.0968e-3 ! Rcm = 2 * pi**2 * me * e**4 / (h**3 * c) real :: alpha0 = 1.0443e-26 ! absorption per electron real , dimension ( nw , 3 ) :: f_coeff integer , parameter :: mdim = 6 real , dimension ( mdim ) :: n1_array , chi_n real , dimension ( nw , mdim ) :: g real :: chi_m real , dimension ( nw ) :: chi , chi1 , nu , wa , wa3 , gff_factor , wcm1 , w1cm5 real , dimension ( nw ) :: s_coeff real :: damping_factor_const , source_function_const contains !************************************************************************************ subroutine calc_wavelength ( w1 , w0 , wa ) ! ! Calculate the wavelength array considering the bounds w0 & w1 set in ! the file \"input.in\" and the number of wavelengths nw set in the file ! \"resoultion.in\". If only one wavelength is requested, return w0. ! real , dimension ( nw ), intent ( out ) :: wa real , intent ( in ) :: w1 , w0 real :: dw integer :: i ! if ( nw > 1 ) then ! using nw-1 next ensures w1 is included in the array dw = ( w1 - w0 ) / ( nw - 1 ) do i = 1 , nw ! wavelengths in angstrom wa ( i ) = w0 + ( i - 1 ) * dw enddo else wa = w0 endif ! print * , 'waves_angstrom min/max' , minval ( wa ), maxval ( wa ) print * , 'number of waves' , nw ! endsubroutine calc_wavelength !************************************************************************************ subroutine pre_calc_opacity_quantities ( waves_angstrom ) ! ! The following quantities are used throughout the radiative transfer calculation. ! They only depend on the wavelength, but since that's our inner-most loop, we ! precalculate them here to save computation time. ! real , dimension ( nw ) :: waves_angstrom , wcm , lgwave integer :: n , iw , i , j ! damping_factor_const = h_planck * c_light_cgs * k1_cgs source_function_const = 2 * h_planck * c_light_cgs ** 2 ! wa = waves_angstrom ! shorthand ! wcm = wa * 1 d - 8 ! wavelengths in cm, shorthand wcm1 = 1. / wcm ! define inverse wavelength nu = c_light_cgs * wcm1 ! frequency: Hz = 1/s ! chi = 1.2398e4 / wa ! equivalent to Χ = hν, using angstroms chi1 = 1. / chi ! wa3 = wa ** 3 w1cm5 = wcm1 ** 5 !==================================================================== ! ! portion of Gaunt factor for hydrogen free-free absorption ! gff_factor = 0.3456 * ( wa * Rangstrom ) ** ( - one_third ) !==================================================================== ! ! Negative hydrogen ion (two electrons) bound-free absorption cross-section ! alpha_bf(H-) = a_0 + a_1*λ + a_2*λ**2 + a_3*λ**3 !              + a_4*λ**4 + a_5*λ**5 + a_6*λ**6 ! a_coeff = ( /+ 1.99654 ,& - 1.18267e-6 ,& + 2.62423e-7 ,& - 4.40524e-11 ,& + 3.23992e-15 ,& - 1.39568e-19 ,& + 2.78701e-24 / ) ! loop through each wavelength and perform the summation s_coeff = 0 do i = 1 , 7 s_coeff = s_coeff + 1e-17 * a_coeff ( i ) * wa ** ( i - 1 ) enddo !==================================================================== ! ! Negative hydrogen ion (two electrons) free-free absorption cross-section ! coefficient array. ! b_coeff = transpose ( reshape ( & ( /- 2.276300 , - 1.685000 , + 0.766610 , - 0.053356 , + 0.000000 ,& + 1 5.28270 , - 9.284600 , + 1.993810 , - 0.142631 , + 0.000000 , & - 19 7.789 , + 19 0.266 , - 6 7.9775 , + 1 0.6913 , - 0.62515 / ), & ( / size ( b_coeff , 2 ), size ( b_coeff , 1 ) / ))) ! do n = 1 , mdim n1_array ( n ) = 1. / n chi_n ( n ) = RydbergEnergy * ( 1. - 1. * n1_array ( n ) ** 2 ) do iw = 1 , nw call gaunt ( n , wcm ( iw ), g ( iw , n )) enddo enddo ! excitation energy of state level m chi_m = RydbergEnergy * ( 1. - n1_array ( mdim ) ** 2 ) ! lgwave = log10 ( wa ) do iw = 1 , nw do i = 1 , 3 f_coeff ( iw , i ) = 0. do j = 1 , 5 f_coeff ( iw , i ) = f_coeff ( iw , i ) + lgwave ( iw ) ** ( j - 1 ) * b_coeff ( i , j ) enddo enddo enddo ! endsubroutine pre_calc_opacity_quantities !************************************************************************************ function get_electron_thomson_scattering ( p ) result ( e_scatter ) real , dimension ( nz ) :: e_scatter real :: alpha_e = 0.6648e-24 ! coefficient type ( pillar_case ) :: p e_scatter = alpha_e * p % nHII * p % inv_number_density endfunction get_electron_thomson_scattering !************************************************************************************ function get_hydrogen_ion_bound_free ( p ) result ( hm_bf_factor ) ! !    A = 4.158e-10 * P_e * θ**2.5 * 10**(0.754 * θ) !  where 0.754 is the ionization potential energy of an electron in the ion ! real , dimension ( nz ) :: hm_bf_factor type ( pillar_case ) :: p ! hm_bf_factor = 4.158e-10 * p % electron_pressure * p % theta ** 2.5 * 10 ** ( 0.754 * p % theta ) endfunction get_hydrogen_ion_bound_free !************************************************************************************ function get_hydrogen_stimulated_emission ( theta , iw ) result ( stim_factor ) real , intent ( in ), dimension ( nz ) :: theta ! theta = 5040./T[K] real , dimension ( nz ) :: stim_factor integer :: iw stim_factor = 1 - 10 ** ( - chi ( iw ) * theta ) endfunction get_hydrogen_stimulated_emission !************************************************************************************ subroutine calc_opacity_and_albedo ( p , iw ) real , dimension ( nz ) :: kappa_rad , kappa_H_bf , kappa_Hm_bf , kappa_Hm_ff integer :: iw type ( pillar_case ) :: p p % stim_factor = get_hydrogen_stimulated_emission ( p % theta , iw ) kappa_H_bf = get_kappa_H_bf ( p , iw ) kappa_Hm_bf = get_kappa_Hm_bf ( p , iw ) kappa_Hm_ff = get_kappa_Hm_ff ( p , iw ) kappa_rad = ( kappa_H_bf + kappa_Hm_bf + kappa_Hm_ff + p % e_scatter ) * mp1 p % opacity = kappa_rad * p % rho ! ! This subroutine changes p%opacity and kappa_rad ! call calc_kappa_H_ff ( p , kappa_rad , iw ) p % albedo = p % e_scatter * mp1 / kappa_rad p % opacity1 = 1. / p % opacity p % opacity2 = p % opacity ** 2 ! p % source_function = get_source_function ( p % T1 , iw ) ! endsubroutine calc_opacity_and_albedo !************************************************************************************ function get_kappa_H_bf ( p , iw ) result ( kappa_H_bf ) ! !    \"\"\"Cross section of bound-free hydrogen. Sums over the first !    1 to m-1 excitation states, where m is the principal quantum !    number and uses the Unsold integral approximation for levels !    m to infinity. Returns units of cm&#94;2 per neutral hydrogen atom. ! !    Parameters !    ---------- !    waves : float !        Wavelength in Angstroms !    temp : float !        Temperature in Kelvin !    m : int, optional !        Principal quantum number at which to begin the Unsold !        integral approximation, by default 6 ! !    Returns !    ------- !    float !        Cross section of bound-free hydrogen in units of cm&#94;2 per !        neutral hydrogen atom !    \"\"\" ! real , dimension ( nz ) :: sm , ktemp , ktemp1 , unsold , kappa_H_bf integer :: n , iw type ( pillar_case ) :: p ! ! sum for the first m-1 excitation states sm = 0. ktemp = k_cgs * p % T ktemp1 = k1_cgs * p % T1 do n = 1 , mdim sm = sm + g ( iw , n ) * n1_array ( n ) ** 3 * exp ( - chi_n ( n ) * ktemp1 ) enddo ! Unsold approximation integral unsold = . 5 * ktemp * RydbergEnergy1 * ( exp ( - chi_m * ktemp1 ) - exp ( - RydbergEnergy * ktemp1 ) ) kappa_H_bf = AHbf * p % stim_factor * p % ionization_factor * wa3 ( iw ) * ( unsold + sm ) endfunction get_kappa_H_bf !************************************************************************************ subroutine calc_kappa_H_ff ( p , kappa_rad , iw ) ! !    \"\"\"Hydrogen free-free absorption coefficient. ! !    Units cm&#94;2 per neutral hydrogen atom. !    \"\"\" real , dimension ( nz ) :: kappa_rad real :: g_ff , energyfactor , kappa_H_ff , opacity_bremsstrahlung integer :: i , iw type ( pillar_case ) :: p ! intent ( inout ) :: kappa_rad ! do i = 1 , nz if (( 1 - p % NHII_NHINHII ( i )) . gt . switch_ionfraction ) then ! Use Gray 2022 function that depends on hydrogen's ionization state. g_ff = 1 + gff_factor ( iw ) * ( p % theta1 ( i ) * log10e * chi1 ( iw ) + 0.5 ) energyfactor = . 5 * log10e * p % theta1 ( i ) * Iev1 * 10 ** ( - p % theta ( i ) * Iev ) kappa_H_ff = p % stim_factor ( i ) * p % ionization_factor ( i ) * alpha0 * wa3 ( iw ) * g_ff * energyfactor kappa_rad ( i ) = kappa_rad ( i ) + kappa_H_ff * mp1 ! cm&#94;2 / g p % opacity ( i ) = p % opacity ( i ) + kappa_rad ( i ) * p % rho ( i ) ! 1/cm else ! Use espression for fully ionized gas. !waves_cm = waves / 1e8 ! convert angstroms to centimeters !nu_Hz = c*1e8 / waves call bremsstrahlung_absorptionCoeff ( p , i , nu ( iw ), 1.0 , opacity_bremsstrahlung ) p % opacity ( i ) = p % opacity ( i ) + opacity_bremsstrahlung kappa_rad ( i ) = kappa_rad ( i ) + p % opacity ( i ) * p % rho1 ( i ) ! cm&#94;2 / g endif enddo endsubroutine calc_kappa_H_ff !************************************************************************************ subroutine bremsstrahlung_absorptionCoeff ( p , i , frequency , zprotons , kappaRho ) real :: gaunt , zprotons , ln_physQuant , kappaRho , frequency integer :: i type ( pillar_case ) :: p intent ( in ) :: zprotons intent ( out ) :: kappaRho gaunt = log ( exp ( 5.960 - sqrt3 * pi1 * log ( frequency * 1e-9 * ( p % T ( i ) * 1e-4 ) ** ( - 1.5 ))) + exp1 ) ln_physQuant = log ( p % ne ( i ) * ( p % nHI ( i ) + p % nHII ( i ))) + & !nelectrons*nprotons 2 * log ( zprotons ) - & 0.5 * log ( p % T ( i )) - & 3 * log ( frequency ) + & log (( 1 - exp ( - h_planck * frequency * k1_cgs * p % T1 ( i )))) kappaRho = bremsstrahlung_constant * exp ( ln_physQuant ) * gaunt endsubroutine bremsstrahlung_absorptionCoeff !************************************************************************************ function get_kappa_Hm_bf ( p , iw ) result ( kappa_Hm_bf ) !    \"\"\"H- ion bound-free continuum opacity. !    Calculates the sum of the fit function ! !        alpha = 1e-18 * sum_m=0&#94;6(a_m * wave&#94;m) ! !    Parameters: waves : 1D array !                    array of wavelengths. Single values !                    must be contained in an array object. ! !    \"\"\" real , dimension ( nz ) :: kappa_Hm_bf integer :: iw type ( pillar_case ) :: p ! fit coefficients if ( wa ( iw ) . lt . 16000 ) then kappa_Hm_bf = p % hm_bf_factor * p % stim_factor * p % ionization_factor * s_coeff ( iw ) else kappa_Hm_bf = 0 endif ! endfunction get_kappa_Hm_bf !************************************************************************************ function get_kappa_Hm_ff ( p , iw ) result ( kappa_Hm_ff ) ! !    \"\"\"H- ion free-free interaction cross section per HI per unit !    electron pressure. !    \"\"\" real , dimension ( nz ) :: kappa_Hm_ff , flam integer :: iw type ( pillar_case ) :: p ! ! fit coefficients flam = f_coeff ( iw , 1 ) + f_coeff ( iw , 2 ) * p % lgtheta + f_coeff ( iw , 3 ) * p % lgtheta2 - 26 kappa_Hm_ff = p % ionization_factor * p % ne * k_cgs * p % T * 10 ** ( flam ) endfunction get_kappa_Hm_ff !************************************************************************************ subroutine gaunt ( n , wave_cm , gaunt_factor ) ! !    \"\"\" !    Calculate Gaunt Factor !    Parameters: n : int !                    principle quantum number !                waves : ndarray !                    wavelengths in Angstroms !    \"\"\" ! integer :: n real :: wave_cm real :: lam_n , eps2_n , gaunt_factor ! intent ( in ) :: n , wave_cm intent ( out ) :: gaunt_factor ! ! reference wavelength lambda_n lam_n = n ** 2 * hcR1 ! gaunt will be non-zero only where wavelengths are shorter than !   lam_n (i.e. the ionizing wavelength) if ( wave_cm . le . lam_n ) then eps2_n = (( wave_cm / lam_n ) - 1 ) ** 2 ! Gaunt factor. Below experession is for lamda <= lambda_n; zero otherwise !121./700=0.17285714285714285 gaunt_factor = 1 - 0.17285714285714285 * ( 1 - eps2_n ) * ( n * ( 1 + eps2_n )) ** ( - two_thirds ) else gaunt_factor = 0.0 endif ! endsubroutine gaunt !************************************************************************************ subroutine grey_parameters ( p , sigma_grey ) real , intent ( in ) :: sigma_grey real , dimension ( nz ) :: alpha_grey type ( pillar_case ) :: p p % source_function = sigma_sb * p % T ** 4 alpha_grey = 3.68e22 * p % T ** ( - 3.5 ) * p % rho p % opacity = ( alpha_grey + sigma_grey ) * p % rho p % albedo = sigma_grey / ( alpha_grey + sigma_grey ) p % opacity1 = 1. / p % opacity p % opacity2 = p % opacity ** 2 endsubroutine grey_parameters !************************************************************************************ function get_source_function ( T1 , iw ) result ( source_function ) integer :: i , iw real , dimension ( nz ) :: T1 , damping_factor real , dimension ( nz ) :: source_function !damping_factor_const = h_planck*c_light_cgs*k1_cgs damping_factor = damping_factor_const * T1 * wcm1 ( iw ) do i = 1 , nz if ( damping_factor ( i ) > log_overflow_limit ) then damping_factor ( i ) = log_overflow_limit endif enddo !source_function_const = 2*h_planck*c_light_cgs**2 source_function = source_function_const * w1cm5 ( iw ) * 1 / ( exp ( damping_factor ) - 1 ) ! endfunction get_source_function !************************************************************************************ endmodule ContinuousOpacity","tags":"","loc":"sourcefile/continuous_opacity.f90.html"},{"title":"flux_feautrier.f90 – Ocotillo","text":"Source Code program flux_feautrier ! !                    _ !                 .'` '`. !              .-\", @ `, `. !             '-=;      ;   `. !                 \\    :      `-. !                 /    ';        `. !                /      .'         `. !                |     (      `.     `-.._ !                 \\     \\` ` `. \\         `-.._ !                  `.   ;`-.._ `-`._.-. `-._   `-._ !                    `..'     `-.```.  `-._ `-.._.' !                      `--..__..-`--'      `-.,' !                         `._)`/ !                          /  / !                         /--( !                      -./,--'`-, !                   ,&#94;--( !                   ,--' `-, !          ___ _ __   __ _ _ __ _ __ _____      __ !         / __| '_ \\ / _` | '__| '__/ _ \\ \\ /\\ / / !         \\__ \\ |_) | (_| | |  | | | (_) \\ V  V / !         |___/ .__/ \\__,_|_|  |_|  \\___/ \\_/\\_/ !             | | !             |_| ! ! !  SPARROW - Spectral Post-processing AGN Radiaton transfeR On multiple Wavelengths ! !  This program calculates 1D radiative transfer for simulation boxes, !  using the Feautrier method. The main application is for AGN disks; !  the temperatures and thus the opacities span several different regimes, !  that are included in the code. ! !  Usage: setup the soft links, make, then run ! !             rt_setup !             make !             ./source/flux_feautrier.x ! !  Authors: Harrison E. Cook !           Wladimir Lyra ! !  © 2024 ! use Auxiliary use Common use Disk use GasState use ContinuousOpacity use ReadAthena use FileIO implicit none type ( pillar_case ) :: p ! ! These memory-intensive quantities are the code output: mean intensity (U), ! flux (V) and opacity (absorp_coeff). Fortran is column major, but the ! calculations will be done in z, so the data is assorted (z,y,x) to have ! that direction be the fastest, for cache efficiency. ! real , dimension ( mz , nyloc , nxloc , nw ) :: U real , dimension (:,:,:,:), allocatable :: V , absorp_coeff ! ! Density and temperature are the athena input. The input will be by xy ! processor and serial in the z direction. ! real , dimension ( nz , nyloc , nxloc ) :: rho3d , temp3d real , dimension ( mz ) :: z ! real , dimension ( nz ) :: a , b , c , d real , dimension ( nw ) :: waves_angstrom real :: dz , z0 , z1 , dz1 , dz2 real :: start , finish real :: start_loop , finish_loop real :: w0 = 3000 , w1 = 5000 real :: sigma_grey integer :: iw , ix , iy , iprocx , iprocy integer :: err logical :: lgrey = . false ., lread_athena = . true . character ( len = 90 ) :: snapshot character ( len = 90 ) :: inputfile = './input.in' ! namelist / input / z0 , z1 , w0 , w1 , sigma_grey , lgrey , lread_athena ! ! Start the time counter. ! call cpu_time ( start ) ! ! The code will take as argument a four string letter to mark the snapshots ! from Athena. If no argument is given, assume it is the 0000 snapshot. ! This is needed to launch the code on multiple snapshots from the command ! line on a cluster for post-processing. ! call getarg ( 1 , snapshot ) if ( snapshot == '' ) snapshot = \"0000\" ! !  Read the input namelist with the user-defined parameters. ! open ( 20 , file = trim ( inputfile )) read ( 20 , nml = input ) close ( 20 ) ! !  Report which athena snapshot is being used. ! if ( lread_athena ) print * , \"snapshot: \" , snapshot ! ! Do a sanity check for grey RT ! if ( lgrey . and .( nw /= 1 )) then print * , \"For Grey RT use only one wavelength. Switch nw=1 in resolution.in\" stop endif ! ! Allocate the arrays for flux and opacity. Make it allocatable because ! otherwise it will allocate too much static memory when the resolution is high. ! It was leading to relocation truncated error R_X86_64_PC32 when running on a ! snapshot of size nz=1280,nyloc=60,nxloc=60,nw=25 as of Dec 2024. ! allocate ( V ( nz , nyloc , nxloc , nw ), stat = err ) if ( err /= 0 ) then print * , \"Could not allocate array of size \" , nz , nyloc , nxloc , nw , \" for array V.\" stop endif ! allocate ( absorp_coeff ( nz , nyloc , nxloc , nw ), stat = err ) if ( err /= 0 ) then print * , \"Could not allocate array of size \" , nz , nyloc , nxloc , nw , \" for array absorp_coeff.\" stop endif ! ! Read the user-defined values for temperature, density, and ionization threshold from input.in ! call read_temperature_input ( inputfile ) call read_density_input ( inputfile ) call read_gas_state_input ( inputfile ) ! ! Calculate the wavelength array. So far only allows linear. ! call calc_wavelength ( w1 , w0 , waves_angstrom ) ! ! Pre-calculate a number of wavelength-related but space- and time-independent quantities, ! to speed up the opacity calculation in run time. ! call pre_calc_opacity_quantities ( waves_angstrom ) ! ! The code primarily deals with athena output but also uses ! artificial inputs for testing and benchmarking purposes if ! lread_athena is false. ! if ( lread_athena ) call read_athena_input ( inputfile ) ! ! Here starts the main loop through processors. The code will loop through each block of ! x and y processors, read the nxloc,nyloc,nzloc information, and go through the z processors ! to reconstitute a nxloc,nyloc,nz array. Then for cache-efficiency it will loop through ! nxloc and nyloc and do operations on the z vertical 1D arrays (pillars). ! procx : do iprocx = 0 , nprocx - 1 procy : do iprocy = 0 , nprocy - 1 lroot = ( iprocx == 0 ) . and . ( iprocy == 0 ) ! ! Read from athena input or construct a fake disk (density and temperature). ! The z direction is global, so only the root xy needs calculate it. ! All others can use it. ! if ( lread_athena ) then call read_from_athena ( z , dz , rho3d , temp3d , iprocx , iprocy , snapshot ) else if ( lroot ) call calc_grid ( z1 , z0 , z , dz ) call calc_density ( p % rho , z ) call calc_temperature ( p % T , z ) endif ! !  Shortcuts for the dz grid resolution. ! if ( lroot ) then dz1 = 1. / dz dz2 = dz ** 2 endif ! ! xy-dependent starts here. ! if ( lroot ) call cpu_time ( start_loop ) ! xloop : do ix = 1 , nxloc yloop : do iy = 1 , nyloc ! ! The fake disk has axisymmetric structure and thus the pillars for density ! and temperature in that case are defined already outside the xyloop. ! Read here the athena input instead. ! if ( lread_athena ) then p % rho = rho3d ( 1 : nz , iy , ix ) p % T = temp3d ( 1 : nz , iy , ix ) endif ! ! Pre-define the pillars needed for the opacity calculation. ! call wavelength_independent_pillars ( p ) ! ! Loop over wavelengths. ! wavelength : do iw = 1 , nw lfirst = lroot . and .( ix == 1 ). and .( iy == 1 ). and .( iw == 1 ) ! ! These subroutines will calculate the opacity, albedo, and source function. ! if ( lgrey ) then call grey_parameters ( p , sigma_grey ) else call calc_opacity_and_albedo ( p , iw ) endif ! ! Having the opacity, albedo, and source function, we can solve for the mean intensity. ! This will be done via a tridiagonal system ! !    a_i U_{i-1} + b_i U_i + c_i U_{i+1} = d_i ! ! The next subroutine will calculate the coefficients a,b,c,d. ! call get_tridag_coefficients ( a , b , c , d , p , dz , dz2 ) ! ! Safety check for no NaNs in the coefficients. ! if ( lfirst ) print * , 'sum(a), sum(b), sum(c), sum(d)=' ,& sum ( a ), sum ( b ), sum ( c ), sum ( d ) ! ! Solve the tridiagonal system to get the mean intensity. ! call tridag ( a , b , c , d , U ( n1 : n2 , iy , ix , iw )) ! ! Calculate the flux V = -1./kappa  * dU/dz. ! The mean intensity needs boundary conditions to calculate the derivative. ! call update_ghosts ( U (:, iy , ix , iw )) call calc_flux ( U (:, iy , ix , iw ), p , dz1 ) ! ! Save opacity and flux into larger memomy arrays for output. ! absorp_coeff (:, iy , ix , iw ) = p % opacity V (:, iy , ix , iw ) = p % flux ! ! Safety check for no NaNs in mean intensity and flux. ! if ( lfirst ) then print * , 'min/max(U)' , minval ( U ( n1 : n2 , iy , ix , iw )), maxval ( U ( n1 : n2 , iy , ix , iw )) print * , 'min/max(V)' , minval ( V (:, iy , ix , iw )), maxval ( V (:, iy , ix , iw )) print * , 'min/max(absorp_coeff)' , minval ( absorp_coeff (:, iy , ix , iw )), maxval ( absorp_coeff (:, iy , ix , iw )) endif ! enddo wavelength enddo yloop enddo xloop ! if ( lroot ) call cpu_time ( finish_loop ) ! ! Calculate post-processing on one column for diagnostic: flux and intensities. ! !  call calc_intensity(U,V,Ip,Im) ! ! Write output ! if ( lroot ) then call output_grid ( z , waves_angstrom ) !Output for diagnostic purposes call output_ascii ( U (:, nyloc , nxloc ,:), absorp_coeff (:, nyloc , nxloc ,:)) endif call output_binary ( U , absorp_coeff , V , iprocx , iprocy , snapshot ) enddo procy enddo procx ! deallocate ( V ) deallocate ( absorp_coeff ) ! ! Finish the time counter and print the wall time ! call cpu_time ( finish ) ! ! Wall time only for the loop, in a single xy processor block. ! print * , '' print * , \"processor column time = \" , finish_loop - start_loop , \" seconds.\" print * , \"Execution time =\" ,( finish_loop - start_loop ) / ( 1 d0 * nz * nyloc * nxloc * nw ) * 1e6 ,& \" micro-seconds per wavelength point per mesh point.\" ! ! Wall time for the whole code ! print * , '' print * , \"Wall time = \" , finish - start , \" seconds.\" print * , \"Execution time =\" ,( finish - start ) / ( 1 d0 * nz * ny * nx * nw ) * 1e6 ,& \" micro-seconds per wavelength point per mesh point.\" ! endprogram flux_feautrier !***********************************************************************","tags":"","loc":"sourcefile/flux_feautrier.f90.html"},{"title":"disk.f90 – Ocotillo","text":"Source Code ! Module for disk model generation/manipulation. module Disk use Common implicit none private public :: read_temperature_input , read_density_input public :: calc_grid , calc_density , calc_temperature real :: isoTemp , sigma , midTemp , floorTemp , switchTemp real :: rho0 , rho_floor , H namelist / temperature_input / isoTemp , sigma , midTemp , floorTemp namelist / density_input / rho0 , rho_floor , H contains !************************************************************************************ subroutine read_temperature_input ( inputfile ) ! character ( len = 90 ) :: inputfile ! open ( 30 , file = trim ( inputfile )) read ( 30 , nml = temperature_input ) close ( 30 ) ! switchTemp = ( 1 + epsi ) * isoTemp ! must be larger than mdiTemp ! endsubroutine read_temperature_input !************************************************************************************ subroutine read_density_input ( inputfile ) ! character ( len = 90 ) :: inputfile ! open ( 30 , file = trim ( inputfile )) read ( 30 , nml = density_input ) close ( 30 ) ! endsubroutine read_density_input !************************************************************************************ subroutine calc_grid ( z1 , z0 , z , dz ) ! real , dimension ( mz ) :: z real :: dz , z1 , z0 integer :: i ! dz = ( z1 - z0 ) / ( nz - 1 ) do i = 1 , nz z ( n1 + i - 1 ) = z0 + ( i - 1 ) * dz enddo ! ! Fill in ghost zones ! print * , z ( n1 ), z ( n2 ) ! do i = 1 , ng z ( n1 - i ) = z ( n1 ) - i * dz z ( n2 + i ) = z ( n2 ) + i * dz enddo ! endsubroutine calc_grid !************************************************************************************ subroutine calc_temperature ( T , z , lfrom_read_athena ) ! real , dimension ( nz ), intent ( inout ) :: T real , dimension ( mz ), intent ( in ) :: z real , dimension ( nz ), save :: Tgauss integer :: i logical , optional :: lfrom_read_athena logical :: lathena logical , save :: lfirst_call = . true . ! if ( present ( lfrom_read_athena )) then lathena = lfrom_read_athena else lathena = . false . endif ! ! Check if it's calling from read_athena. Otherwise ! assign to the midTemp value from input.in ! if (. not . lathena ) T = midTemp ! ! Calculate the gaussian profile ! if ( lfirst_call ) then Tgauss = midTemp * exp ( - 0.5 * z ( n1 : n2 ) ** 2 / sigma ** 2 ) lfirst_call = . false . endif ! ! If the temperature is greater than the switch temperature, ! it will use the current value (e.g. the Athena input. ! Else choose between the gaussian profile or the floor. ! do i = 1 , nz if ( T ( i ) < switchTemp ) then if ( Tgauss ( i ) > floorTemp ) then T ( i ) = Tgauss ( i ) else T ( i ) = floorTemp endif endif enddo ! if (. not . lathena ) & ! if read from read_athena, it already prints there print * , \"maxval(T), minval(T)\" , maxval ( T ), minval ( T ) ! endsubroutine calc_temperature !************************************************************************************ subroutine calc_density ( rho , z ) ! real , dimension ( nz ), intent ( inout ) :: rho real , dimension ( mz ), intent ( in ) :: z integer :: i ! rho = rho0 * exp ( - . 5 * z ( n1 : n2 ) ** 2 / H ** 2 ) ! ! Implement a density floor ! do i = 1 , nz if ( rho ( i ) < rho_floor ) then rho ( i ) = rho_floor endif enddo ! print * , \"maxval(rho), minval(rho)\" , maxval ( rho ), minval ( rho ) ! endsubroutine calc_density !************************************************************************************ endmodule Disk","tags":"","loc":"sourcefile/disk.f90.html"},{"title":"auxiliary.f90 – Ocotillo","text":"Source Code module Auxiliary !! Auxiliary subroutines used throughout the code. use Common implicit none private public :: tridag , update_ghosts , der public :: calc_intensity , calc_flux public :: get_tridag_coefficients contains !==================================================================================== subroutine tridag ( a , b , c , r , u ) !! Solves a tridiagonal system of equations. !! Imported from numerical recipes. ! real , dimension (:), intent ( in ) :: a , b , c , r !! Coefficients for the left-hand side (a, b, c) !! and value of the right-hand side (r) real , dimension (:), intent ( out ) :: u !! Value for which to solve. real , dimension ( size ( b )) :: gam !! Intermediate step variable. integer :: n , j !! n : size of b, j : do-loop integer real :: bet !! Intermediate step variable. ! n = size ( b ) bet = b ( 1 ) if ( bet == 0.0 ) then print * , \"ERROR tridiag stage 1: bet=b(1)) = \" , bet , \": cannot be zero.\" stop endif ! u ( 1 ) = r ( 1 ) / bet do j = 2 , n gam ( j ) = c ( j - 1 ) / bet bet = b ( j ) - a ( j ) * gam ( j ) if ( bet == 0.0 ) then print * , \"ERROR tridiag stage 2: bet = b(j)-a(j)*gam(j) =\" , bet , \": cannot be zero.\" stop endif u ( j ) = ( r ( j ) - a ( j ) * u ( j - 1 )) / bet enddo ! do j = n - 1 , 1 , - 1 u ( j ) = u ( j ) - gam ( j + 1 ) * u ( j + 1 ) enddo ! endsubroutine tridag !==================================================================================== subroutine update_ghosts ( f ) !! Update the ghost zones of an array !! using constant gradient. Used on U. ! real , dimension (:), intent ( inout ) :: f !! Array to update. integer :: i !! Looping integer. ! do i = 1 , ng f ( n1 - i ) = 2 * f ( n1 ) - f ( n1 + i ) f ( n2 + i ) = 2 * f ( n2 ) - f ( n2 - i ) enddo ! endsubroutine update_ghosts !==================================================================================== subroutine der ( f , df ) !! Calculate the sixth-order first derivative of an array. ! real , dimension ( mz ) :: f !! Array to calculate the derivative including ghost zones. real , dimension ( nz ) :: df !! Derivative of the array. ! intent ( in ) :: f intent ( out ) :: df ! df = 1. / 6 0. * ( + 4 5.0 * ( f ( n1 + 1 : n2 + 1 ) - f ( n1 - 1 : n2 - 1 )) & - 9.0 * ( f ( n1 + 2 : n2 + 2 ) - f ( n1 - 2 : n2 - 2 )) & + ( f ( n1 + 3 : n2 + 3 ) - f ( n1 - 3 : n2 - 3 ))) ! endsubroutine der !==================================================================================== subroutine calc_intensity ( U , V , Ip , Im ) !* Calculate upwards (Ip) and downwards (Im) intensities !  from U and V. ! !   I_{\\rm p} = U + V  !*  I_{\\rm m} = U - V  ! real , dimension ( mz , nw ) :: U !! Mean intensity array. real , dimension ( nz , nw ) :: V , Ip , Im !! Flux, upward intensity, and downward intensity. integer :: iw !! Wavelength loop index. ! do iw = 1 , nw Ip (:, iw ) = U ( n1 : n2 , iw ) + V (:, iw ) Im (:, iw ) = U ( n1 : n2 , iw ) - V (:, iw ) enddo ! endsubroutine calc_intensity !==================================================================================== subroutine calc_flux ( U , p , dz1 ) !! Calculate flux (V) from the mean intensity (U) and opacity (\\kappa) !!  V = -\\frac{1}{\\kappa} * \\frac{dU}{dz}  ! real , dimension ( mz ) :: U !! Mean intensity array. real , dimension ( nz ) :: dU !! First derivative of the mean intensity. type ( pillar_case ) :: p !! Pillar object containing the radiative transfer quantitites. real :: dz1 !! Inverse of the grid size along z: 1/dz ! ! Calculate dU call der ( U , dU ) ! Calculate flux p % flux = - 1 * p % opacity1 * dU * dz1 endsubroutine calc_flux !==================================================================================== subroutine get_tridag_coefficients ( aa , bb , cc , dd , p , dz , dz2 ) !! Fill in the coefficients of the system of equations in U. !! @note !! Center and boundary coefficients are calculated differently. !! @endnote ! real , dimension ( nz ), intent ( inout ) :: aa , bb , cc , dd !! Tridiag system coefficients real , intent ( in ) :: dz , dz2 !! Grid size (dz) and its square (dz2) along z. type ( pillar_case ) :: p !! Pillar object to update. ! call fill_center_coeffs ( aa , bb , cc , dd , p , dz2 ) call fill_boundary_coeffs ( aa , bb , cc , dd , p , dz , dz2 ) ! endsubroutine get_tridag_coefficients !==================================================================================== subroutine fill_center_coeffs ( aa , bb , cc , dd , p , dz2 ) !! Populate the center coefficients of the tridiagonal system !! for zones i=2 to i=nz-1. ! !! i.e.: ! !!         _                                          _      _        _ ! !!       \\|    a_2    b_2    c_2       0       ...     \\|  \\|   d2     \\| ! !!       \\|           ...                              \\| =\\|   ...    \\| ! !!       \\|                  ...                       \\| =\\|   ...    \\| ! !!       \\|                           ...              \\| =\\|   ...    \\| ! !!       \\|_   ...     0    a_{nz-1}   b_{nz-1}   c_{nz-1}  _\\|  \\|_ d_{nz-1} _\\| !! @note !! On notation below: `kappa_*` have the same units as `p%opacity`. !! @endnote ! real , dimension ( nz ), intent ( inout ) :: aa , bb , cc , dd !! Tridiagonal system coefficients real , dimension ( nz ) :: kappa_m , kappa_p !! Opacities at the half points below (`kappa_m`) and above (`kappa_p`). real , intent ( in ) :: dz2 !! Square of the grid size along z. real :: zeta !! Intermediate variable for easy reading. integer :: iz !! Loop variable over z. type ( pillar_case ) :: p !! Pillar object. ! Populate opacities at point i+1/2 do iz = 1 , nz - 1 kappa_p ( iz ) = 0.5 * ( p % opacity ( iz + 1 ) + p % opacity ( iz )) enddo ! Populate opacities at point i-1/2 do iz = 2 , nz kappa_m ( iz ) = 0.5 * ( p % opacity ( iz ) + p % opacity ( iz - 1 )) enddo ! Populate centers of arrays ! Each coefficient is multiplied by opacity**2 to match the order !   of the boundary coefficients. do iz = 2 , nz - 1 aa ( iz ) = p % opacity2 ( iz ) / kappa_m ( iz ) cc ( iz ) = p % opacity2 ( iz ) / kappa_p ( iz ) zeta = dz2 * p % opacity ( iz ) ** 3 * ( 1 - p % albedo ( iz )) bb ( iz ) = - ( aa ( iz ) + cc ( iz ) + zeta ) dd ( iz ) = - p % source_function ( iz ) * zeta enddo if ( lfirst ) print * , ' Filled center coeffs' endsubroutine fill_center_coeffs !==================================================================================== subroutine fill_boundary_coeffs ( aa , bb , cc , dd , p , dz , dz2 ) !! Populate the center coefficients of the tridiagonal system !! for zones i=1 and i=nz. !! i.e.: !!        a_1 [  b_1  c_1    0    ...   ]       =  [   d_1   ] !! and !!            [  ...   0   a_{nz}  b_{nz}   ] c_{nz}  =  [  d_{nz}  ] ! real , dimension ( nz ), intent ( inout ) :: aa , bb , cc , dd !! Tridiagonal system coefficients. real , intent ( in ) :: dz , dz2 !! Grid size (dz) and its square (dz2) along z. real :: zeta !! Intermediate variable for easy reading. ! type ( pillar_case ) :: p !! Pillar object ! Populate boundary values aa ( 1 ) = 0. zeta = p % opacity ( 1 ) * dz2 * ( 1 - p % albedo ( 1 )) * . 25 bb ( 1 ) = - ( p % opacity1 ( 1 ) + dz + zeta ) * p % opacity2 ( 1 ) cc ( 1 ) = p % opacity ( 1 ) dd ( 1 ) = - p % source_function ( 1 ) * zeta * p % opacity2 ( 1 ) aa ( nz ) = p % opacity ( nz ) zeta = p % opacity ( nz ) * dz2 * ( 1 - p % albedo ( nz )) * . 25 bb ( nz ) = - ( p % opacity1 ( nz ) + dz + zeta ) * p % opacity2 ( nz ) cc ( nz ) = 0. dd ( nz ) = - p % source_function ( nz ) * zeta * p % opacity2 ( nz ) if ( lfirst ) print * , ' Filled boundary coeffs' endsubroutine fill_boundary_coeffs !==================================================================================== endmodule Auxiliary","tags":"","loc":"sourcefile/auxiliary.f90.html"},{"title":"gas_state.f90 – Ocotillo","text":"Source Code ! Module to calculate the gas state module GasState use Common use ContinuousOpacity implicit none private public :: calc_hydrogen_ion_frac , solve_gas_state public :: get_electron_pressure , read_gas_state_input public :: wavelength_independent_pillars real :: fully_ionized_T namelist / gas_state_input / fully_ionized_T contains !****************************************** subroutine read_gas_state_input ( inputfile ) integer :: iu character ( len = 90 ) :: inputfile open ( newunit = iu , file = trim ( inputfile )) read ( iu , nml = gas_state_input ) close ( iu ) endsubroutine read_gas_state_input !****************************************** subroutine wavelength_independent_pillars ( p ) ! type ( pillar_case ) :: p ! p % rho1 = 1. / p % rho p % T1 = 1. / p % T call calc_hydrogen_ion_frac ( p ) call solve_gas_state ( p ) p % electron_pressure = get_electron_pressure ( p ) p % e_scatter = get_electron_thomson_scattering ( p ) p % theta = 504 0. * p % T1 p % theta1 = 1. / p % theta p % lgtheta = log10 ( p % theta ) p % lgtheta2 = p % lgtheta ** 2 p % hm_bf_factor = get_hydrogen_ion_bound_free ( p ) ! endsubroutine wavelength_independent_pillars !****************************************** subroutine calc_hydrogen_ion_frac ( p ) real , dimension ( nz ) :: constants , niine_ni , c_ion , exparg integer :: i type ( pillar_case ) :: p ! ! calculate the Saha equation (relative fraction of adjacent ions) ! !constants = (sqrt(2*pi*me*k_cgs)*h1_planck)**3   * T**1.5 !(sqrt(2*pi*me*k_cgs)*h1_planck)**3 = 2414683039571967.0 constants = 241468303957196 7. * p % T ** 1.5 exparg = p % T1 * hydrogen_ionization_eV * k1_eV niine_ni = constants * exp ( - exparg ) c_ion = mp * p % rho1 * niine_ni p % NHII_NHINHII = . 5 * ( sqrt ( c_ion ** 2 + 4 * c_ion ) - c_ion ) ! ! Limits due to machine precision mean 4C becomes unresolved next to C**2, ! so manually set the ionization fraction to 1 for temperatures above 20000. ! This is appropriate for our domain where the density is always less than ! ~2e-9 g cm&#94;-3. Would not be appropriate for higher densities. ! do i = 1 , nz if ( p % T ( i ) > fully_ionized_T ) then p % NHII_NHINHII ( i ) = 1. endif enddo ! endsubroutine calc_hydrogen_ion_frac !****************************************** subroutine solve_gas_state ( p ) !rho,rho1,NHII_NHINHII,number_density,inv_number_density,& !     nHI,nHII,ne,ionization_factor) !real, dimension(nz), intent(in) :: rho,rho1,NHII_NHINHII !real, dimension(nz), intent(out) :: number_density,inv_number_density,nHI,nHII,ne,ionization_factor integer :: i type ( pillar_case ) :: p p % number_density = p % rho * mp1 p % inv_number_density = p % rho1 * mp p % nHII = p % NHII_NHINHII * p % number_density p % nHI = p % number_density - p % nHII p % ne = p % nHII do i = 1 , nz if ( p % nHI ( i ) /= 0 ) then p % ionization_factor ( i ) = p % nHI ( i ) / ( p % nHI ( i ) + p % nHII ( i )) else ! set to zero. p % ionization_factor ( i ) = 0. endif enddo endsubroutine solve_gas_state !****************************************** function get_electron_pressure ( p ) result ( electron_pressure ) ! function  for electron pressure !real, intent(in), dimension(nz) :: ne, T real , dimension ( nz ) :: electron_pressure type ( pillar_case ) :: p electron_pressure = p % ne * k_cgs * p % T endfunction get_electron_pressure !****************************************** endmodule GasState","tags":"","loc":"sourcefile/gas_state.f90.html"}]}